use Inventory_Management
create table products(
product_id int,
product_name varchar(30),
category varchar(20),
price int,
stock int)
load data infile 'd:/products.csv'
into table products
fields terminated by ',' 
enclosed by '"'
lines terminated by '\n'
ignore 1 rows;
create table orders(
order_id int,
customer_id int,
product_id int,
order_date date,
quantity int,
`status` varchar(20),
total_price int)
load data infile 'd:/orders.csv'
into table orders
fields terminated by ','
enclosed by '"'
lines terminated by '\n'
ignore 1 rows;
create table customers(
customer_id int,
customer_name varchar(50),
email varchar(60),
join_date date,
region varchar(25))
load data infile "d:\customers.csv"
into table customers
fields terminated by ','
enclosed by '"'
lines terminated by '\n'
ignore 1 rows;
select * from orders
select * from customers
select * from products
select customer_name
from (
    select c.customer_name, sum(o.total_price) as total_spent
    from customers c
    join orders o on o.customer_id = c.customer_id
    group by c.customer_id, c.customer_name
    order by sum(o.total_price) desc
    limit 5
) as top_customers;
select c.customer_name from customers c
join orders o on o.customer_id = c.customer_id
group by c.customer_name
order by sum(o.total_price) desc
limit 5
select p.product_name from products p
where not exists (select 1 from orders o
where o.product_id = p.product_id)
select p.product_id, p.product_name
from products p
left join orders o on p.product_id = o.product_id
where o.product_id is null;
select c.customer_name, round(avg(o.total_price),0) from customers c
join orders o on c.customer_id = o.customer_id
group by c.customer_name
having avg(o.total_price) > 200
select customer_name, avg_order_value from
(select c.customer_name, avg(o.total_price) as avg_order_value from customers c
join orders o on c.customer_id = o.customer_id
group by c.customer_name) as customer_avg_orders
where avg_order_value >200
select region from (
select c.customer_name, c.region from customers c
join orders o on c.customer_id = o.customer_id
where year(c.join_date) > 2022
and o.order_id is not null) as customer_purchase
with top_products as (
select p.category, sum(o.total_price) as total_revenue
from orders o 
join products p on p.product_id = o.product_id
group by p.category)
select category, total_revenue from top_products 
order by total_revenue limit 3
with month_revenue as (
select month(order_date) as mon, sum(total_price) as revenue
from orders
where year(order_date) = 2023
group by mon)
select mon, revenue from month_revenue
order by revenue desc
limit 1
select month(order_date) as mon, sum(total_price) as revenue
from orders where year(order_date) = 2023
group by mon
order by revenue desc 
limit 1
select * from orders
select * from products
with cancelled_product as (
select p.product_name,count(*) as total_orders, sum(case 
         when o.`status` = "cancelled" then 1 else 0
         end) as status_count
	from orders o
    join products p on o.product_id = p.product_id
    group by p.product_name)
    select product_name, (status_count*100/total_orders) as cancel_percent from cancelled_product
with customer_details as(
select c.customer_name, count(o.order_id) as lifetime_count, 
sum(o.total_price) as total_spend
from customers c
join orders o on c.customer_id = o.customer_id
group by c.customer_name)
select * from customer_details
------ "stored procedure that accepts a customer id as a parameter and returns the total number of orders placed by that customer"
delimiter $$
create procedure get_customer_count(
in
input_customer_id int,
out total_orders int
)
begin
select count(customer_id)
into total_orders from orders
where input_customer_id = customer_id;
end $$
select @total_orders;
call get_customer_count(14,@total_orders)
select @total_orders;
-------- "stored procedure to dynamically create a query that retrieves data from a table whose name is passed as a parameter"
delimiter $$
create procedure customer_data(
in 
new_customer_name varchar(225))
begin
select c.customer_id, c.customer_name, o.product_id, 
sum(o.total_price) as total_spent from customers c
join orders o on c.customer_id = o.customer_id
where new_customer_name = c.customer_name
group by c.customer_id, c.customer_name, o.product_id;
end $$
select * from customers
drop procedure if exists customer_data
call customer_data("customer_14")
select * from products
------ "stored procedure that calculates the total revenue generated by each product category and stores the result in a summary table"
delimiter $$
create procedure product_category(
in category varchar(50))
begin
insert into category_revenue (category, total_revenue)
(select p.category, sum(o.total_price) as total_revenue
from products p join
orders o on p.product_id = o.product_id
group by p.category);
end $$
create table category_revenue(
category varchar(50),
total_revenue int)
drop procedure if exists product_category 
call product_category('electronics');
select * from category_revenue
--------- "stored procedure that inserts a new order into the orders table. if the customer id does not exist, raise a custom error message"
delimiter $$
create procedure new_insert_order(
 in input_customer_id int,
 in input_product_id int,
 in input_order_date date,
 in input_total_price decimal(10,2),
 out result_message varchar(225)
 )
 begin
  if not exists (
  select 1
  from customers
  where customer_id = input_customer_id)
  then
  set result_message = concat('error: customer_id', input_customer_id, 'does not exist.');
  else
  insert into orders (customer_id, product_id, order_date, total_price)
  values (input_customer_id, input_product_id, input_order_date,input_total_price);
  set result_message = 'order inserted successfully.';
  end if;
  end $$
  ----- "stored procedure to handle order creation deduct the product quantity from the inventory insert a record in the orders table commit or roll back the transaction if any step fails"
  delimiter $$
  create procedure createorder(
  in input_customer_id int,
  in input_product_id int, 
  in input_order_date date,
  in input_quantity int,
  in input_total_price decimal(10,2),
  out result_message varchar(225)
  )
  begin
  declare product_stock int;
  declare exit handler for sqlexception
  begin
  rollback;
  set result_message = 'transaction failed. changes rolled back.';
  end;
  order_block: begin
  start transaction;
  select quantity into product_stock
  from orders
  where product_id = input_product_id;
  if product_stock is null then
  rollback;
  set result_message = concat('error:product_id', input_product_id,'does not exists in inventory.');
  leave order_block;
   elseif product_stock < input_quantity then
   rollback;
   set result_message = concat('error: not enough stock for product id ', input_product_id, '.');
   leave order_block;
   end if;
  update inventory
  set quantity = quantity - input_quantity
  where product_id = input_product_id;
  insert into orders (customer_id, product_id, 	order_date,quantity, total_price)
  values (input_customer_id, input_product_id,input_order_date, input_quantity,input_total_price);
  commit;
  set result_message = 'order created successfully.';
  end order_block;
  end $$
  drop procedure createorder
  call createorder (4,104,'2024-12-24',2,15,@result_message);
  select @result_message
  
delimiter $$
create procedure getcustomerbydaterange(
in start_date date,
in end_date date)
begin
select distinct c.customer_id, c.customer_name
from customers c
join orders o on c.customer_id = o.customer_id
where o.order_date between start_date and end_date;
end $$
call getcustomerbydaterange ('2020-01-01', '2020-04-30');

delimiter $$
create trigger updatestockordernew
after insert on orders
for each row
begin
update products
set stock_quantity = quantity - new_quantity
where product_id = new.product_id;
if (select stock from products where product_id = new_product_id)<0 then
signal sqlstate '45000'
set message_text  = 'stock quantity cannot be negative';
end if;
end $$
select * from orders
select * from products
insert into orders (order_id, customer_id, product_id,order_date,quantity,`status`,total_price) values
(101,1,5,'2024-12-27',45, 'completed',5000);

create table monthlyrevenuereport (
    reportid int auto_increment primary key,
    reportdate date not null,
    region varchar(50) not null,
    totalrevenue decimal(18, 2) not null,
    generatedat timestamp default current_timestamp
);

delimiter $$
create procedure generatemonthlyrevenuereport()
begin
    declare reportdate date;
	set reportdate = last_day(curdate() - interval 1 month);
	insert into monthlyrevenuereport (reportdate, region, totalrevenue)
    select
        reportdate as reportdate,
        region,
        sum(revenue) as totalrevenue
    from
        salesdata  
    where
        saledate >= date_format(reportdate, '%y-%m-01') 
        and saledate <= reportdate 
    group by
        region;
end$$
delimiter $$
create event monthlyrevenuetrigger
on schedule every 1 month
starts last_day(curdate()) + interval 1 second
do
    call generatemonthlyrevenuereport();
$$
set global event_scheduler = on;



